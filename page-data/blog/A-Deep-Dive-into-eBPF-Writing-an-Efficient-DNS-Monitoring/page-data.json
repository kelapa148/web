{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/A-Deep-Dive-into-eBPF-Writing-an-Efficient-DNS-Monitoring","result":{"data":{"site":{"siteMetadata":{"title":"#COCONUT"}},"markdownRemark":{"html":"<p>eBPF is an in-kernel virtual machine, provides a high-level library, instruction set and an execution environment inside the Linux kernel. It’s used in many Linux kernel subsystems, most prominently networking, tracing, debugging and security. Including to modify the processing of packets in the kernel and also allows the programming of network devices such as SmartNICs.</p>\n<p>I will not talk here detail about what eBPF is. A lot of posts have already been published about the eBPF and in a variety of languages. Although many of these are fairly informative, they don’t answer the most important questions: How does the eBPF process packets and monitor the packet take from the host to the user?. I will describe the process of creating an actual application from the beginning, especially in monitoring requests, responses and process in DNS, gradually enriching the functionality and accompanying all this with explanations, comments, and links to the source code. And sometimes a little off the side because you want to give a few more examples, not just a solution to a specific problem. As a result, I hope those who want to get acquainted with eBPF will spend less time searching for useful materials and start programming faster.</p>\n<h2>Introduction</h2>\n<p>Let’s say the host can send legitimate DNS requests, but the IP addresses it will send them are unknown. In the network filter log, you can see that the requests are still coming. But it’s not clear — is this just legitimate, or is the information already leaking to the attackers? It would be easier if the domain to which the server sends data were known. Unfortunately, PTR is out of fashion, and securitytrails show either nothing or too much on this IP.</p>\n<p>You can run tcpdump. But who wants to look at the monitor constantly? And if there is more than one server? There is a packetbeat from ELK Stack and this is a monster that has eaten out the processor on all my servers. Osquery is a good tool that knows much about network connections and not about DNS queries. The relevant offer was closed. Zeek — I learned about it while looking for how to track DNS queries. It seems like it’s not bad, but I was confused by two points: it monitors not only DNS, which means resources will be spent on work that I don’t need the result of (although, perhaps, you can select protocols in the settings); and it also doesn’t know anything about which process sent the request.</p>\n<p>We will write in Python and start with the simplest — we will understand how Python and eBPF interact. First, we will install these packages:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\">#apt install python3-bpfcc bpfcc-tools libbpfcc linux-headers-$(uname -r)</span></code></pre></div>\n<p>This is for Ubuntu. But if you go into the kernel, finding the necessary packages for your distribution should not be a problem. Now let’s get started:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#!/usr/bin/env python3</span>\n<span class=\"token keyword\">from</span> bcc <span class=\"token keyword\">import</span> BPF\nFIRST_BPF <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">r\"\"\"\nint first(void *ctx) {\n  bpf_trace_printk(\"Hello world! execve() is calling\\n\");\n  return 0;\n}\n\"\"\"</span>\nbpf <span class=\"token operator\">=</span> BPF<span class=\"token punctuation\">(</span>text<span class=\"token operator\">=</span>FIRST_BPF<span class=\"token punctuation\">)</span>\nbpf<span class=\"token punctuation\">.</span>attach_kprobe<span class=\"token punctuation\">(</span>event<span class=\"token operator\">=</span>bpf<span class=\"token punctuation\">.</span>get_syscall_fnname<span class=\"token punctuation\">(</span><span class=\"token string\">\"execve\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> fn_name<span class=\"token operator\">=</span><span class=\"token string\">\"first\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">,</span> event_b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> bpf<span class=\"token punctuation\">.</span>trace_fields<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        events <span class=\"token operator\">=</span> event_b<span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token string\">'Hello world'</span> <span class=\"token keyword\">in</span> events<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>events<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">except</span> ValueError<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">continue</span>\n    <span class=\"token keyword\">except</span> KeyboardInterrupt<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">break</span></code></pre></div>","frontmatter":{"date":"August 30, 2022","path":"/blog/A-Deep-Dive-into-eBPF-Writing-an-Efficient-DNS-Monitoring","title":"A Deep Dive into eBPF: Writing an Efficient DNS Monitoring","thumbnail":"/assets/blogs/ebpf_nurkholish_halim.png","metaDescription":"A Deep Dive into eBPF - Writing an Efficient DNS Monitoring","author":"Nurkholish Halim"}}},"pageContext":{}},"staticQueryHashes":["3159585216","440143384"]}